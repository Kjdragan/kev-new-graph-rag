# Research Report: Hybrid RAG Query System Design (LlamaIndex, Graphiti, Google GenAI)

**Date:** 2025-06-14
**Objective:** Document the research process, findings, and decisions made during the design of a hybrid RAG query system, focusing on integrating LlamaIndex with Graphiti-managed Neo4j databases and Google Gemini models via the `google-genai` SDK.

## 1. Initial Context & Goals

The primary goal is to build a robust hybrid RAG system capable of:
-   Leveraging both vector search (ChromaDB) and graph search (Neo4j with Graphiti).
-   Using Google Gemini models for LLM tasks (embeddings, query generation, synthesis) via the latest `google-genai` SDK, adhering to user preferences for `uv` package management.
-   Integrating Graphiti's temporal relationship features (`valid_at`, `invalid_at`, `expired_at`) into Cypher queries generated by LlamaIndex.
-   Utilizing LlamaIndex for advanced RAG capabilities like multi-tool routing (`RouterQueryEngine`), Text-to-Cypher, and response synthesis.

## 2. Google GenAI SDK Integration with LlamaIndex

**Challenge:** Ensure compatibility with the latest `google-genai` SDK for all Gemini model interactions, as opposed to the older `google-generativeai` SDK.

**Findings & Decisions:**
-   Initial research indicated potential confusion between `llama-index-llms-gemini` and `llama-index-llms-google-genai`.
-   **Key Finding:** The `Gemini` class in `llama-index-llms-gemini` uses the **deprecated** `google-generativeai` SDK.
-   **Decision:** To comply with user requirements and best practices, the project will use:
    -   `GoogleGenAI` class from `llama_index.llms.google_genai` (provided by the `llama-index-llms-google-genai` package) for all LLM functionalities.
    -   `GoogleGenAIEmbedding` class from `llama_index.embeddings.google_genai` (provided by the `llama-index-embeddings-google-genai` package) for generating embeddings.
-   These components were confirmed to support the necessary features for advanced RAG, including synchronous/asynchronous operations, streaming, chat, and tool/function calling, making them suitable for LlamaIndex's `RouterQueryEngine` and other sophisticated workflows.

## 3. LlamaIndex Graph Querying Components

**Objective:** Identify the appropriate LlamaIndex components for Text-to-Cypher generation and graph querying, and determine how to customize them for Graphiti.

**Research & Evolution:**

### 3.1. Initial Exploration: `KnowledgeGraphQueryEngine`
-   Searched for LlamaIndex components capable of Text-to-Cypher.
-   `KnowledgeGraphQueryEngine` was an initial candidate.
-   **Investigation:** Viewed the source code for `KnowledgeGraphQueryEngine` (`llama-index-core/llama_index/core/query_engine/knowledge_graph_query_engine.py`).
-   **Key Finding 1:** The `KnowledgeGraphQueryEngine` accepts a `graph_query_synthesis_prompt` parameter in its `__init__` method. This indicated a potential customization point for injecting Graphiti-specific logic.
    ```python
    # From KnowledgeGraphQueryEngine source
    def __init__(
        self,
        llm: Optional[LLM] = None,
        storage_context: Optional[StorageContext] = None,
        graph_query_synthesis_prompt: Optional[BasePromptTemplate] = None, # <-- Customization point
        # ... other params
    ):
    ```
-   **Key Finding 2 (Crucial):** The `KnowledgeGraphQueryEngine` is **deprecated** as of LlamaIndex version 0.10.53.
    ```python
    # Deprecation notice in KnowledgeGraphQueryEngine source
    @deprecated.deprecated(
        version="0.10.53",
        reason=(
            "KnowledgeGraphQueryEngine is deprecated. It is recommended to use "
            "the PropertyGraphIndex and associated retrievers instead."
        ),
    )
    ```
-   **Decision:** Shift focus from `KnowledgeGraphQueryEngine` to `PropertyGraphIndex` and its associated retrievers, as recommended by the LlamaIndex team.

### 3.2. Focused Exploration: `PropertyGraphIndex` and `TextToCypherRetriever`
-   Following the deprecation notice, research shifted to `PropertyGraphIndex`.
-   **Investigation:**
    -   Searched for `PropertyGraphIndex` source code: found in `llama-index-core/llama_index/core/indices/property_graph/base.py`.
    -   Searched for `TextToCypherRetriever` source code: identified path `llama-index-core/llama_index/core/indices/property_graph/sub_retrievers/text_to_cypher.py` from GitHub issue discussions.
    -   Viewed the source code for `TextToCypherRetriever`.
-   **Key Finding:** The `TextToCypherRetriever` class's `__init__` method accepts a `text_to_cypher_template` parameter.
    ```python
    # From TextToCypherRetriever source
    class TextToCypherRetriever(BasePGRetriever):
        # ...
        def __init__(
            self,
            graph_store: PropertyGraphStore,
            llm: Optional[LLM] = None,
            text_to_cypher_template: Optional[Union[PromptTemplate, str]] = None, # <-- Key Customization Point
            # ... other params
        ) -> None:
            # ...
            self.text_to_cypher_template = (
                text_to_cypher_template or graph_store.text_to_cypher_template # Can also come from graph store
            )
    ```
-   **Decision:** The `text_to_cypher_template` parameter in `TextToCypherRetriever` (used in conjunction with `PropertyGraphIndex`) is the primary mechanism for customizing Cypher query generation to be Graphiti-aware.

## 4. Graphiti Temporal Logic for Cypher Queries

**Objective:** Understand Graphiti's temporal model (`valid_at`, `invalid_at`, `expired_at`) to construct accurate Cypher `WHERE` clauses for retrieving active relationships.

**Investigation & Findings:**
-   Initial `grep_search` for temporal terms in `graphiti_core/search/search_utils.py` yielded no results, which was unexpected.
-   A broader `grep_search` across the entire `graphiti_core` (local path: `c:\Users\kevin\repos\graphiti\graphiti_core`) revealed that temporal logic is primarily handled in `graphiti_core/utils/maintenance/` (specifically `temporal_operations.py`, `edge_operations.py`, `graph_data_operations.py`).
-   **Key observations from Graphiti source code:**
    -   `valid_at`, `invalid_at`, `expired_at` are properties of relationships (edges).
    -   These timestamps are often parsed from ISO format and made UTC-aware.
    -   `valid_at` and `invalid_at` can be determined by an LLM during data extraction or by Graphiti's internal contradiction resolution logic.
    -   `expired_at` is typically set to `utc_now()` by the system when a relationship is confirmed as no longer current/active, often in conjunction with `invalid_at` being set.
    -   Indexes are created on `e.valid_at`, `e.invalid_at`, and `e.expired_at` for performance.
    -   The function `resolve_extracted_edge` in `edge_operations.py` contains logic for setting `expired_at`:
        ```python
        # From graphiti_core/utils/maintenance/edge_operations.py - resolve_extracted_edge
        if resolved_edge.invalid_at and not resolved_edge.expired_at:
            resolved_edge.expired_at = now # now is utc_now()
        # ... further logic for expiring based on newer contradictory candidates
        ```
    -   The function `resolve_edge_contradictions` in `edge_operations.py` handles setting `invalid_at` and `expired_at` on older edges when newer, superseding information is found.

**Derived Cypher Logic for Active Relationships:**
Based on the Graphiti codebase analysis, a relationship `r` is considered active and valid at a given `$current_datetime` if the following conditions are met:

```cypher
WHERE r.valid_at IS NOT NULL AND r.valid_at <= $current_datetime
  AND (r.invalid_at IS NULL OR r.invalid_at > $current_datetime)
  AND r.expired_at IS NULL
```

This logic ensures:
1.  The relationship's validity period has started.
2.  The relationship has not been invalidated yet (or its invalidation is in the future).
3.  The relationship has not been explicitly marked as expired by the system.

**Additional Graphiti Considerations for Prompts:**
-   **Dual Node Labels:** Graphiti uses a dual-label system for nodes (e.g., `(n:Entity:Person)`). The Text-to-Cypher prompt must instruct the LLM to use this convention.
-   **Ontology-Specific Property Names:** The prompt should guide the LLM to use the correct property names as defined in the project's ontology (e.g., `organization_name` instead of a generic `name`, as per Memory `11381b00-35db-4c7d-864f-1f5ee2fb135f`).

## 5. Summary of Key Integration Points for Custom Prompt

-   **LlamaIndex Component:** `TextToCypherRetriever` (used with `PropertyGraphIndex`).
-   **Customization Parameter:** `text_to_cypher_template`.
-   **Graphiti Requirements for Prompt:**
    1.  Instruction to use dual node labels (e.g., `:Entity:SpecificType`).
    2.  Instruction to incorporate the temporal filtering clause for all relationships:
        `r.valid_at IS NOT NULL AND r.valid_at <= $current_datetime AND (r.invalid_at IS NULL OR r.invalid_at > $current_datetime) AND r.expired_at IS NULL`.
    3.  Guidance to use ontology-specific property names.
    4.  Mechanism to pass the graph schema (node labels, relationship types, properties) to the LLM.
    5.  Mechanism to pass the `$current_datetime` parameter at query time.

This research provides a solid foundation for drafting the custom prompt template and planning its integration into the hybrid RAG system.

## 6. Clarifications on Schema, Ontology, and Querying Strategy (Discussion on 2025-06-14)

Following the initial draft of the custom prompt and implementation plan, several key points were discussed and clarified:

### 6.1. Schema Derivation from Custom Ontology and Existing Neo4j Instance

**Context:** The prompt template uses a `{schema}` placeholder. It's crucial that this schema aligns with the project's custom `universal_ontology.py` and the existing Neo4j database populated by Graphiti.

**Clarifications:**
-   **Custom Ontology is Paramount:** The schema provided to LlamaIndex's `TextToCypherRetriever` (via the `{schema}` placeholder) **must** accurately reflect the `universal_ontology.py`.
    -   **Node Labels:** The schema must list the *specific* node types from the ontology (e.g., "Person", "Organization", "Event") which are used in Graphiti's dual-label system (e.g., `:Entity:Person`).
    -   **Property Names:** The schema must use the exact property names defined in the Pydantic models within `universal_ontology.py` (e.g., `person_name`, `organization_name`).
-   **LlamaIndex Schema Source:** The `Neo4jPropertyGraphStore` component in LlamaIndex is responsible for providing this schema. It can infer it from the connected Neo4j database or allow explicit definition. We must ensure it accurately reflects the Graphiti-generated structure.
-   **Leveraging Existing Ingested Data:** The LlamaIndex integration will query the *existing* Neo4j instance populated by Graphiti. No changes to the ingestion pipeline or already ingested data are needed for this step; the focus is on making LlamaIndex's querying aware of this structure.

**Conclusion:** The implementation plan item "1. Prepare the Graph Schema for LlamaIndex" inherently includes ensuring the `Neo4jPropertyGraphStore` accurately represents the structure defined by `universal_ontology.py` and present in the Neo4j database. The custom prompt is designed to work with this specific Graphiti structure.

### 6.2. Considerations for Dual-Path Querying (Graphiti-Enhanced vs. "Standard" LlamaIndex)

**Question:** Is it feasible or advisable to have two graph querying paths: one using the custom Graphiti-aware prompt and another using a "standard" LlamaIndex approach without Graphiti's temporal/label conventions?

**Clarifications:**
-   **Technical Feasibility:** Setting up two distinct `TextToCypherRetriever` instances (one with the custom prompt, one with a default/simpler prompt) is technically possible within LlamaIndex.
-   **Impact on Graphiti-Populated Database:**
    -   The Neo4j database is structured by Graphiti with dual node labels and temporal properties (`valid_at`, `invalid_at`, `expired_at`) on relationships.
    -   A "standard" LlamaIndex query approach, unaware of these conventions, would likely:
        -   **Retrieve Temporally Inaccurate Data:** It would fetch relationships that are no longer valid (e.g., past `invalid_at` or `expired_at` is set), leading to incorrect answers for current-state queries.
        -   **Struggle with Node Matching:** It might misinterpret or fail to correctly match nodes due to the dual-label system if the schema representation isn't handled carefully.
-   **Use Cases for "Standard" Path:**
    -   **Historical Analysis:** Potentially useful for queries like "show all relationships ever recorded," where temporal validity is intentionally ignored.
    -   **Debugging/Comparison:** For understanding differences in results.
-   **Recommendation:**
    -   For the primary goal of accurate RAG on **current, valid information**, the Graphiti-aware prompt (Path A) is essential to leverage Graphiti's semantic enhancements.
    -   Introducing a "standard" path (Path B) for current-state queries on the same Graphiti-populated database would likely lead to less accurate results and confusion.
    -   If a distinct need for non-temporal historical queries arises, a separate, specialized graph querying tool could be considered later. This would be a strategic addition for a different query type, not a general alternative.

**Conclusion:** The primary focus remains on implementing and refining the Graphiti-aware querying approach. A dual-path strategy for querying the same graph data with different semantics adds complexity and is best deferred unless a specific, distinct use case for non-temporal queries is identified.
